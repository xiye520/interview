# redis  

* 吊打面试官系列：
	> - [《吊打面试官》系列-Redis基础](https://juejin.im/post/5db66ed9e51d452a2f15d833)
	> - [《吊打面试官》系列-缓存雪崩、击穿、穿透](https://juejin.im/post/5dbef8306fb9a0203f6fa3e2)
	> - [《吊打面试官》系列-Redis哨兵、持久化、主从、手撕LRU](https://juejin.im/post/5dc3a9fbf265da4d3c072eab)
	> - [《吊打面试官》系列-Redis终章_凛冬将至、FPX_新王登基](https://juejin.im/post/5dc850b4e51d452c2308ee27)
	> - [《吊打面试官》系列-Redis常见面试题（带答案）](https://juejin.im/post/5dcaebea518825571f5c4ab0)


* 张铁蕾--底层数据结构 [Redis系列文章——合集](https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=509777776&idx=1&sn=e56f24bdf2de7e25515fe9f25ef57557&mpshare=1&scene=1&srcid=1010HdkIxon3icsWNmTyecI6#rd)
  > - [Redis源码从哪里读起？](http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261663&idx=1&sn=949aec03a6edf0b2281d5d83147ba367&chksm=84479186b33018903b9a3664d4de17ab83b62760e456ffcf32e9319d03964892fac6d0a7c208&scene=21#wechat_redirect)
  > - [基于Redis的分布式锁到底安全吗（下）](http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261521&idx=1&sn=7bbb80c8fe4f9dff7cd6a8883cc8fc0a&chksm=84479e08b330171e89732ec1460258a85afe73299c263fcc7df3c77cbeac0573ad7211902649&scene=21#wechat_redirect)
  > - [基于Redis的分布式锁到底安全吗（上）](http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261514&idx=1&sn=47b1a63f065347943341910dddbb785d&chksm=84479e13b3301705ea29c86f457ad74010eba8a8a5c12a7f54bcf264a4a8c9d6adecbe32ad0b&scene=21#wechat_redirect)
  > - [Redis内部数据结构详解(7)——intset](http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261457&idx=1&sn=fe966f3825b81e9d50a2cf38dac9060c&chksm=84479e48b330175ea07905e791856cca5fc50694db9fd4c3485ba5dc097443e69f5ed28a34b5&scene=21#wechat_redirect)
  > - [Redis内部数据结构详解(6)——skiplist](http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261425&idx=1&sn=d840079ea35875a8c8e02d9b3e44cf95&scene=21#wechat_redirect)
  > - [Redis内部数据结构详解(5)——quicklist](http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261335&idx=1&sn=053d72a348be2e78040f3847f4092d92&scene=21#wechat_redirect)
  > - [Redis内部数据结构详解(4)——ziplist](http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261265&idx=1&sn=e105c4b86a5640c5fc8212cd824f750b&scene=21#wechat_redirect)
  > - [Redis内部数据结构详解(3)——robj](http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261237&idx=1&sn=380d183332d41d24ea6f88a54f533fc3&scene=21#wechat_redirect)
  > - [Redis内部数据结构详解(2)——sds](http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261213&idx=1&sn=0ddddf48929610a4155bd82794cad4fa&scene=21#wechat_redirect)
  > - [Redis内部数据结构详解(1)——dict](http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261203&idx=1&sn=f7ff61ce42e29b874a8026683875bbb1&scene=21#wechat_redirect)


* 分布式锁相关：
	> - [基于Redis的分布式锁实现](https://juejin.im/post/5cc165816fb9a03202221dd5)
	> - [部门老大：redis 分布式锁再这么用，我就劝退你](https://juejin.im/post/5e9ff1766fb9a03c3b2bddab)
	> - [对不起，网上的那些 Redis 分布式锁都有漏洞！](https://mp.weixin.qq.com/s/-ZPB30mp683Y19fhbUJ22A)
	> - [redis 分布式锁的 5个坑，真是又大又深](https://www.cnblogs.com/chengxy-nds/p/12750502.html)


* 敖丙：
  > [《我们一起进大厂》系列- Redis基础](https://juejin.im/post/5db66ed9e51d452a2f15d833)
  > [Redis-避免缓存穿透的利器之BloomFilter](https://juejin.im/post/5db69365518825645656c0de)


* [看完这篇缓存穿透的文章，又能和面试官互扯了~]( https://juejin.im/post/5ea63da1e51d4546c4236252)
* [Redis 为什么用跳表而不用平衡树？](https://juejin.im/post/57fa935b0e3dd90057c50fbc#heading-0)
* [天天用Redis，持久化方案有哪些你知道吗？]( https://juejin.im/post/5e9cfe1a518825737d49e7e7)
* [2020年11个Redis系列高频面试题，哪些你还不会？](https://juejin.im/post/5e85a933e51d45470245efaf)
* [Redis高频面试题及答案](https://mp.weixin.qq.com/s/AgWmiuvT0v6_2qVIYwV8Bg)
* [阿里一面：关于【缓存穿透、缓存击穿、缓存雪崩、热点数据失效】问题的解决方案](https://juejin.im/post/5c9a67ac6fb9a070cb24bf34)
* [第三十二章：Redis数据类型](https://zhuanlan.zhihu.com/p/43788306)
* [第三十六章：Redis的主从复制](https://zhuanlan.zhihu.com/p/44376199)
* [第三十七章：Redis Sentinel哨兵机制](https://zhuanlan.zhihu.com/p/44474652)
* [第三十八章：Redis集群的搭建](https://zhuanlan.zhihu.com/p/44747130)
* []()
* []()
* []()





## 一、Redis持久化机制

### 1.1 RDB

- RDB持久化是把当前进程数据生成快照保存到硬盘的过程， 触发RDB持久化过程分为手动触发和自动触发。
- RDB完成后会自动生成一个文件，保存在`dir`配置的指定目录下，文件名是`dbfileName`指定。
- Redis默认会采用LZF算法对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，默认开启。

#### 手动触发

- 手动触发的命令有`save`和`bgsave`。
- `save`：该命令会阻塞Redis服务器，直到RDB的过程完成，已经被废弃，因此线上不建议使用。
- `bgsave`：每次进行RDB过程都会fork一个子进程，由子进程完成RDB的操作，因此阻塞只会发生在fork阶段，一般时间很短。

#### 自动触发

- 除了手动触发RDB，Redis服务器内部还有如下几个场景能够自动触发RDB：
  1. 根据我们的 `save m n` 配置规则自动触发。
  2. 如果从节点执行全量复制操作， 主节点自动执行bgsave生成RDB文件并发送给从节点。
  3. 执行`debug reload`命令重新加载Redis时， 也会自动触发save操作。
  4. 默认情况下执行shutdown命令时， 如果没有开启AOF持久化功能则自动执行`bgsave`。

#### RDB执行流程

- RDB的主流方式就是bgsave，RDB的执行流程，如下：

   ![RDB执行流程](https://user-gold-cdn.xitu.io/2020/4/20/1719540935186502?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. 执行bgsave命令后，会先判断是否存在AOF或者RDB的子进程，如果存在，直接返回。
2. 父进程fork操作创建一个子进程，fork操作中父进程会被阻塞。
3. fork完成后，copy on write，子进程加载，父子共享数据段，父进程继续提供读写，新写入的脏页会放入buffer内存缓冲区中，子进程开始父进程的内存生成临时快照文件，完成后对原有的RDB文件进行替换。执行`lastsave`命令可以查看最近一次的RDB时间。
4. 子进程完成后发送信号给父进程，父进程更新统计信息。

#### RDB的优点

- RDB是一个紧凑压缩的二进制文件， 代表Redis在某个时间点上的数据快照。 非常适用于备份， 全量复制等场景。 比如每6小时执行`bgsave`备份，并把RDB文件拷贝到远程机器或者文件系统中，用于灾难恢复。
- Redis加载`RDB`恢复数据远远快于`AOF`的方式。

#### RDB的缺点

- RDB方式数据没办法做到`实时持久化`/`秒级持久化`。 因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。
- RDB文件使用特定二进制格式保存， Redis版本演进过程中有多个格式的RDB版本， 存在老版本Redis服务无法兼容新版RDB格式的问题。

### 1.2 AOF

- `AOF`（append only file） 持久化： 以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。 AOF的主要作用是解决了数据持久化的实时性， 目前已经是Redis持久化的`主流方式`。

#### 如何开启AOF

- 开启AOF功能需要设置配置：`appendonly yes`， 默认不开启。 AOF文件名通过`appendfilename`配置设置， 默认文件名是`appendonly.aof`。 保存路径同RDB持久化方式一致，通过`dir`配置指定。

#### AOF整体的执行流程

- AOF执行的流程大致分为`命令写入`、`文件同步`、`文件重写`、`重启加载`四个步骤，如下图： ![AOF执行流程](https://user-gold-cdn.xitu.io/2020/4/20/1719540935bbcea6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 命令写入

- AOF命令写入的内容直接是文本协议格式。 例如`set hello world`这条命 令， 在AOF缓冲区会追加如下文本：

```
*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n
复制代码
```

- 命令写入是直接写入到AOF的缓冲区中，至于为什么？原因很简单，Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘， 那么性能完全取决于当前硬盘负载。先写入缓冲区`aof_buf`中， 还有另一个好处， Redis可以提供多种缓冲区 同步硬盘的策略，在性能和安全性方面做出平衡。

#### 文件同步

- Redis提供了多种AOF缓冲区同步文件策略， 由参数`appendfsync`控制，如下：
  - 配置为`always`时， 每次写入都要同步AOF文件， 在一般的SATA硬盘上，Redis只能支持大约几百TPS写入， 显然跟Redis高性能特性背道而驰，不建议配置。
  - 配置为`no`，由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。
  - 配置为`everysec`（默认的配置），是**建议的同步策略**， 也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据（当然，这是不太准确的）。

#### 文件重写机制

- 随着命令不断写入AOF， 文件会越来越大， 为了解决这个问题， Redis引入AOF重写机制压缩文件体积。 AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。
- **为什么要文件重写呢？** 因为文件重写能够使得AOF文件的体积变得更小，从而使得可以更快的被Redis加载。
- 重写过程分为手动触发和自动触发。
  - 手动触发直接使用`bgrewriteaof`命令。
  - 根据`auto-aof-rewrite-min-size`和`auto-aof-rewrite-percentage`参数确定自动触发时机。
- `auto-aof-rewrite-min-size`：表示运行AOF重写时文件最小体积， 默认为64MB。
- `auto-aof-rewrite-percentage`：代表当前AOF文件空间（`aof_current_size`） 和上一次重写后AOF文件空间（`aof_base_size`） 的比值。
- 自动触发时机相当于**aof_current_size>auto-aof-rewrite-minsize&&（aof_current_size-aof_base_size） /aof_base_size>=auto-aof-rewritepercentage**。其中`aof_current_size`和`aof_base_size`可以在`info Persistence`统计信息中查看。
- **那么文件重写后的AOF文件为什么会变小呢？** 有如下几个原因：
  1. 进程内已经超时的数据将不会再次写入AOF文件中。
  2. 旧的AOF文件含有无效命令，如`del key1`、 `hdel key2`等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。
  3. 多条写命令可以合并为一个， 如：`lpush list a`、 `lpush list b`、`lpush listc`可以转化为：`lpush list a b c`。为了防止单条命令过大造成客户端缓冲区溢出，对于`list`、 `set`、 `hash`、 `zset`等类型操作，以64个元素为界拆分为多条。
- 介绍了文件重写的系列知识，下面来看看Redis内部是如何进行文件重写的，如下图： ![文件重写](https://user-gold-cdn.xitu.io/2020/4/20/1719540936b02496?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
- 看完上图，大致了解了文件重写的流程，对于重写的流程，补充如下：
  1. 重写期间，主线程并没有阻塞，而是在执行其他的操作命令，依然会向旧的AOF文件写入数据，这样能够保证备份的最终完整性，如果数据重写失败，也能保证数据不会丢失。
  2. 为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个缓冲区，防止新写的文件丢失数据。
  3. 重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。
  4. AOF文件直接采用的`文本协议`，主要是兼容性好、追加方便、可读性高可认为修改修复。
  5. 无论是`RDB`还是`AOF`都是先写入一个临时文件，然后通过`重命名`完成文件的替换。

#### AOF的优点

- 使用 AOF 持久化会让 Redis 变得非常耐久：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。

#### AOF的缺点

- 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间。
- 数据恢复速度相对于RDB比较慢。

### 1.3 AOF和RDB的区别

- RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
- AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

### 1.4 重启加载

- 无论是RDB还是AOF都可用于服务器重启时的数据恢复，执行流程如下图： ![重启加载流程](https://user-gold-cdn.xitu.io/2020/4/20/17195409372562d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
- 上图很清晰的分析了Redis启动恢复数据的流程，先检查AOF文件是否开启，文件是否存在，再检查RDB是否开启，文件是否存在。

### 1.5 性能问题与解决方案

- 通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。
- 那么如何减少fork操作的阻塞呢？
  1. 优先使用物理机或者高效支持fork操作的虚拟化技术。
  2. 控制Redis实例最大可用内存， fork耗时跟内存量成正比， 线上建议每个Redis实例内存控制在10GB以内。
  3. 合理配置Linux内存分配策略，避免物理内存不足导致fork失败。
  4. 降低fork操作的频率，如适度放宽AOF自动触发时机，避免不必要的全量复制等。



## 二、什么是缓存雪崩、缓存穿透、缓存击穿？

​		一言概之：缓存穿透类似偷袭，绕过radis，袭击数据库。缓存击穿类似正面硬刚，一直进攻一个地方，直到失效时一起涌入攻击数据库。缓存雪崩类似鬼子进村。

#### 2.1 缓存穿透

- **缓存穿透**其实是指从缓存中没有查到数据，而不得不从后端系统（比如数据库）中查询的情况。
- 缓存毕竟是在内存中，不可能所有的数据都存储在 Redis 中，因此少量的缓存穿透是不可避免的，也是系统能够承受的，但是一旦在瞬间发生大量的缓存穿透，数据库的压力会瞬间增大，后果可想而知。
- 在开发中使用缓存的方案如下图，在查询数据库之前会先查询 Redis： ![Redis缓存](https://user-gold-cdn.xitu.io/2020/4/27/171b960b9c43c260?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
- 缓存穿透的整个过程分为如下几个步骤：
  1. 应用查询缓存，**缓存不命中**
  2. DB 层查询不命中，**不将空结果缓存**
  3. 返回空结果
  4. 下一个请求继续重复1,2,3步。

### 解决方案

- 万事万物都是相生相克，既然出现了缓存穿透，就一定有避免的方案。
- 下面介绍两种缓存的方案，分别是`缓存空值`、`布隆过滤器`。

###### 缓存空值

- 回顾缓存穿透的定义知道，**大量空值没有缓存导致重复的访问 DB 层**，由此解决方案也是很明显了，直接将返回的空值也缓存即可。

###### 布隆过滤器

- 1970 年布隆提出了一种布隆过滤器的算法，用来判断一个元素是否在一个集合中。这种算法由一个二进制数组和一个 Hash 算法组成。
- 具体的算法思想这里不再详细解释了，如有不了解的可以看陈某上一篇文章[大白话布隆过滤器，又能和面试官扯皮了~](https://mp.weixin.qq.com/s/Vo935pCXH0aPgG20f1ppEg)。
- 解决缓存穿透的大致思想：**在访问缓存层和存储层之前，可以通过定时任务或者系统任务来初始化布隆过滤器，将存在的 key 用布隆过滤器提前保存起来，做第一层的拦截**。

### 两种方案对比

- 两种方案各有优缺点，具体使用哪种方案还是要根据业务场景和系统体量来定。具体的区别如下表：

| 方案       | 适用场景                                  | 维护成本                                                 |
| ---------- | ----------------------------------------- | -------------------------------------------------------- |
| 缓存对象   | 1. 数据命中不高 2. 数据频繁变化，实时性高 | 代码维护点单、需要过多的缓存空间，数据一致性需要自己实现 |
| 布隆过滤器 | 1. 数据命中不高 2.数据相对固定，实时性低  | 代码维护复杂、缓存空间占用少                             |

### 2.2缓存击穿

​	缓存击穿，这个跟**缓存雪崩**有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是**缓存击穿**是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

影响：会造成某一时刻数据库请求量过大，压力剧增。

如何解决：上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。

其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。

### 2.3 缓存雪崩

​	缓存雪崩的情况是说，当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉。

##### 解决办法：

* 事前：**使用集群缓存，保证缓存服务的高可用**

这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。

* 事中：**ehcache本地缓存 + Hystrix限流&降级,避免MySQL被打死**

使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。

使用 Hystrix进行限流 & 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。

然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。

* 事后：**开启Redis持久化机制，尽快恢复缓存集群** 	

  一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。




#### 三、

  

## 四、Memcache与Redis的区别都有哪些？

1、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis

有部份存在硬盘上，redis可以持久化其数据

2、数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据

类型 ，提供list，set，zset，hash等数据结构的存储

3、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自

己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

4、 value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。

5、redis的速度比memcached快很多

6、Redis支持数据的备份，即master-slave模式的数据备份。

## 五、redis的过期策略以及内存淘汰机制

redis采用的是定期删除+惰性删除策略。

为什么不用定时删除策略?

定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。

在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.

定期删除+惰性删除是如何工作的呢?

定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是

每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂

不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。

于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了

过期时间那么是否过期了？如果过期了此时就会删除。

采用定期删除+惰性删除就没其他问题了么?

不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，

redis的内存会越来越高。那么就应该采用内存淘汰机制。

在redis.conf中有一行配置

```
maxmemory-policy volatile-lru复制代码
```

该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)
```
1.volatile-lru(least recently used):最近最少使用算法，从设置了过期时间的键中选择空转时间最长的键值对清除掉；
2.volatile-lfu(least frequently used):最近最不经常使用算法，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉；
3.volatile-ttl:从设置了过期时间的键中选择过期时间最早的键值对清除；
4.volatile-random:从设置了过期时间的键中，随机选择键进行清除；
5.allkeys-lru:最近最少使用算法，从所有的键中选择空转时间最长的键值对清除；
6.allkeys-lfu:最近最不经常使用算法，从所有的键中选择某段时间之内使用频次最少的键值对清除；
7.allkeys-random:所有的键中，随机选择键进行删除；
8.noeviction:不做任何的清理工作，在redis的内存超过限制之后，所有的写入操作都会返回错误；但是读操作都能正常的进行;
```
ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。


## 六、Redis 为什么是单线程的

官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问

1、绝大部分请求是纯粹的内存操作（非常快速）

2、采用单线程,避免了不必要的上下文切换和竞争条件

3、非阻塞IO优点：

（1）速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)

（2）支持丰富数据类型，支持string，list，set，sorted set，hash

（3）支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

（4）丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题

同时有多个子系统去set一个key。这个时候要注意什么呢？ 不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。

(1)如果对这个key操作，不要求顺序： 准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可作了。以此类推。

(2) 利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证读写key的一致性对redis的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,redis内部已经帮你处理好并发的问题了。

## 七、Redis 常见性能问题和解决方案？

1、Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件

2、 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次

3、为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内

4、尽量避免在压力很大的主库上增加从库

5、主从复制不要用图状结构，用单向链表结构更为稳定，即： Master <- Slave1 <- Slave2 <-Slave3…

## 八、为什么Redis的操作是原子性的，怎么保证原子性的？

对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。

Redis的操作之所以是原子性的，是因为Redis是单线程的。

Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。

多个命令在并发中也是原子性的吗？

不一定， 将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua==的方式实现.

## 九、Redis事务

Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的

Redis会将一个事务中的所有命令序列化，然后按顺序执行。

1、redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可

以保持简单且快速。

2、如果在一个事务中的命令出现错误，那么所有的命令都不会执行；

3、如果在一个事务中出现运行错误，那么正确的命令会被执行。

（1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。

（2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。

（3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。

（4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。



## 十、底层数据结构

在Redis中，dict也是一个基于哈希表的算法。和传统的哈希算法类似，它采用某个哈希函数从key计算得到在哈希表中的位置，采用拉链法解决冲突，并在装载因子（load factor）超过预定值时自动扩展内存，引发重哈希（rehashing）。Redis的dict实现最显著的一个特点，就在于它的重哈希。它采用了一种称为增量式重哈希（incremental rehashing）的方法，在需要扩展内存时避免一次性对所有key进行重哈希，而是将重哈希操作分散到对于dict的各个增删改查的操作中去。这种方法能做到每次只对一小部分key进行重哈希，而每次重哈希之间不影响dict的操作。dict之所以这样设计，是为了避免重哈希期间单个请求的响应时间剧烈增加，这与前面提到的“快速响应时间”的设计原则是相符的。