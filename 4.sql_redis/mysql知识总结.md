# mysql知识点总结
* 参考链接：https://www.jianshu.com/p/2d97e48513d3
* [什么是 MySQL 索引?](https://zhuanlan.zhihu.com/p/117419077)
* [【MyBatis学习11】MyBatis中的延迟加载](https://blog.csdn.net/eson_15/article/details/51668523).
* [mybatis 延迟加载](https://juejin.im/post/5c3d518df265da614171cabe)
* [MySQL主从延迟现象及原理分析详解](http://www.uxys.com/html/MySQL/20200213/69964.html)
* [MySQL中的重做日志（redo log），回滚日志（undo log），以及二进制日志（binlog）的简单总结](https://www.cnblogs.com/wy123/p/8365234.html)
* [详细分析MySQL事务日志(redo log和undo log)](https://juejin.im/entry/5ba0a254e51d450e735e4a1f)
* [从原理上理解MySQL的优化建议](https://juejin.im/post/5ec9224f518825432b5dcf11)
* [100道MySQL数据库经典面试题解析（收藏版）](https://juejin.im/post/5ec15ab9f265da7bc60e1910)
* []()
* [MySQL十道面试题](https://mp.weixin.qq.com/s/g0jxr_CEFwFb-517vxY_XQ)
* [Mysql性能优化：什么是索引下推？](https://zhuanlan.zhihu.com/p/121084592)
* []()

## Mysql架构图

![img](https://user-gold-cdn.xitu.io/2020/4/18/1718b1b5ef3e58df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

大致上来说，MySQL 可以分为 `Server`层和 `存储引擎`层。

Server 层包括连接器、查询缓存、分析器、优化器、执行器，包括大多数 MySQL 中的核心功能，所有跨存储引擎的功能也在这一层实现，包括 **存储过程、触发器、视图等**。

存储引擎层包括 MySQL 常见的存储引擎，包括 **MyISAM、InnoDB 和 Memory** 等，最常用的是 InnoDB，也是现在 MySQL 的默认存储引擎。



## 1.mysql事务
#### 什么是事务
```
事务就是数据库操作的最小单元。一个事务里面包含诺干逻辑要么全部成功要么全部失败。事务是一组不可
再分割的操作集合。
```
#### 事务的四大特性
```
1. 原子性: 事务包含的操作逻辑是不可再分的。要么全部成功。要么全部失败

2. 一致性: 是对数据的可见性的约束，就是所有数据要么是事务开始前的样子.要么全是结束的样子，不
存在中间过渡是的数据。

3. 隔离性: 事务与事务之间是不受影响的。

4. 持久性: 事务一旦提交，那么它对数据库的改变应该是永久的。接下来的操作或者故障不会对其有影响。
```
#### 事务的隔离级别
```
1. 读未提交: 事务可以看见其他的事务还没提交的修改. 比如一个事务a在对一行数据进行修改,修改完后又删除.
这整个过程对于别的事务来说都是透明的.这个级别的事务就基本没有隔离性.

2. 读以提交: 事务只能够看到其他的事务已经提交后的修改,当前的事务运行的时候可能会有多个事务已经对某行
数据进行了修改,并且已经提交,所以多次查询同一行的数据可能会不一样.所以又被成为"不可重复读".

3. 可重复读: 事务在这个级别有数据版本控制,只会看到事务一开始的数据版本,所以数据不管读多少次都是一样的
是innodb的默认级别.

4. 串行化:   事务完全串行的执行.隔离级别最高,但是性能很差.
```
##### 脏读,不可重复读,幻读分别是什么
* 脏读:事务a对数据库进行了修改还没提交, 这个数据被事务b看到了并且使用,事务a因为一些原因撤销了数据,事务
b就相当于发生了脏读.
* 不可重复读:事务a在运行的时候可能会因为有多个事务的提交而对同一行数据进行查询多次结果不一样. 
* 幻读:当事务a查找多行数据的时候,可能会因为事务b的插入或者删除而影响到.

|隔离级别	|脏读	|不可重复读|	幻读|
|---|---|---|---|
|读未提交	|会	    |会	    |会|
|读以提交	|不会	|会	    |会|
|可重复读	|不会	|不会	|会|
|串行化	    |不会	|不会	|不会|

#### mysql不同级别的事务是怎么实现的
* 原子性:首先事务的原子性规定了事务要么全部成功要么全部失败. 这是通过mysql的undo log 来实现的.举个例子
当事务a对行数据加了5,undo log就会生成一个减5的log.当事务执行到一半失败了进行回滚 就会运行undo log
上的相关sql.

* 持久性:事务一旦提交数据就会生效,即使数据库崩溃数据也不会丢失,这是因为mysql在提交的那一刻就sql语句就已
经被记录在redo log里.

* 隔离性:级别越低的隔离性所能够承受的并发越高.不同的隔离性的实现其实就是(读写锁和mvcc的不同运用).首先最
低级别的读未提交允许同一时间读写并行,同一时间一行数据只能被一个事务修改.正因为读不加锁,所以会出现脏读的
情况.读已提交: 事务中每次查询都会生成一个数据版本,所以每次查询都会读到当前最新的数据,可重复读:事务一开
始的时候就会生成一个数据版本号,所以不管数据怎么查都是查到指定版本数据。串行化:所有事务按照顺序执行。

## 2.mysql索引
#### 什么是索引
索引是对数据库表中的一列或多列的值进行排序的一种结构,使用索引可以提高数据库的查询速度。索引是一个单独的
存储在磁盘上的数据库结构，它们包含着对数据库表里所有记录的引用指针。

#### hash和b+ tree索引的优劣
* hash索引只能精确查找做等值查询，不能范围查找，查找速度比 b+tree速度快很多.hash索引占用磁盘空间较大因为
有很多没有命中的hash槽浪费了空间。

* b+tree 支持联合索引的最左匹配原则。支持模糊查找。范围查找。一般情况下比hash速度慢，但是性能稳定。

#### 聚簇索引和覆盖索引和回表
* 聚簇索引:就是索引最终直接指向整行数据。一般就是主键索引。如果没有设置主键，innodb底层会选择一个唯一
的非空的索引代替。如果没有这样的索引，innodb就会隐式的定义一个主键来作为聚簇索引。当走这个索引查询数剧
就只需要查询完成就能够获得到目标数据。

* 回表:当sql走的不是聚簇索引的时候，该索引的叶子指向聚簇索引的id。mysql会通过当前索引找到主键id。然后
拿到主键id去查询主键索引。这个过程就称之为回表，回表的话相当于要走多个索引性能相对来说会慢点。

* 覆盖索引:举个例子 索引a 是字段a,b的联合索引，如果一个 sql语句通过 索引a 查找字段a,b 。那么当前的索
引已经能够查到所需要的数据，所以就不需要回表查询主键索引。

#### 为什么选b+tree 作为索引的数据结构
* b+ tree 的节点会存多个子节点，比起b tree 。b+ tree的数据全部存在叶子节点，非叶子节点只会存键。这样
能够存更多的关系数据。能够更快的命中。树高越低，磁盘io次数越少。b+树的树高 < b树高 < 平衡二叉树

* 更加适合范围查找:在b树进行范围查找是，要先找到查找的下限，然后对b树进行中序遍历，直到找到查找的上限，
而b+树的范围查找，只需要对链接进行遍历即可。

* b tree 的查询复杂度在 1 到树高之间，而b+树的查询复杂度稳定为树高，因为所有数据节点都在叶子节点。

#### 存储引擎 MYISAM 和 INNODB 的区别
```
1. myisam 只支持表锁，innodb支持行级锁
2. myisam 不支持事务, innodb支持
3. myisam 的表结构 数据 索引是单独存放的。innodb是索引和数据是放一起的
4. select count(*) from table 的时候myisam 不需要遍历整表因为它对总行数有保存，innodb 需要遍历。
5. myisam支持全文索引，innodb不支持。
```

## 3.Mysql死锁
* 原因
多个事务在不同的资源占用后，并且请求对方占用的资源。并且不释放。导致逻辑卡死。

#### 死锁检测
```
innodb能检测到死锁的循环依赖，并立即返回错误，但是涉及到外部锁，或者表锁的情况下，innodb不能完全检测
到。需要设置锁等待超时时间 innodb_lock_wait_timeout来解决。
```

#### 死锁恢复
```
死锁发生后只有部分或者完全回滚其中一个事务，才能打破死锁。innodb 现在就是将持有最少的行级排它锁的事务
进行回滚。
```

#### myisam会不会产生死锁
```
不会。因为myiasm在事务一开始的时候就会先获取自己所需要的所有锁。所以不会发生死锁的情况。
```

#### innodb死锁避免
1. 可以在事务一开始的时候先尝试获得所有需要的锁。获得了再进行操作。`SELECT ... FOR UPDATE`
2. 不同的事务尽量以相同的顺序访问表。这样加锁流程也会一样。也会降低死锁产生的机会
3. 改变事务隔离级别

## 四、索引的创建规则

#### B+TREE改进点及优势所在：

\- 仍然是N叉树，层级小，非叶子节点不再存储数据，数据只存储在同一层的叶子节点上，B+树从根到每一个节点的路径长度一样，而B树不是这样

\- 叶子之间，增加了链表(图中红色箭头指向)，获取所有节点，不再需要中序遍历，使用链表的next节点就可以快速访问到

\- 范围查找方面，当定位min与max之后，中间叶子节点，就是结果集，不用中序回溯（范围查询在SQL中用得很多，这是B+树比B树最大的优势）

\- 叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储

\- 非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引

可以来初步计算一下：假设key、子树节点指针均占用4B，则B树一个节点占用4 + 4 = 8B，一页页面大小4KB，则N = 4 * 1024 / 8B = 512，一个512叉的B树，1000w的数据，深度最大 log(512/2)(10^7) 约等于4。对比二叉树如AVL的深度为log(2)(10^7) 约为24，相差了5倍以上！

假如一个节点大小是4KB，一个KEY有8字节，一页可以存4000/8=500个KEY，根据N叉树特点,就算一层500叉节点，则：

第一层树：1个节点，1*500KEY , 大小4K

第二层树：500节点 500*500=25万个KEY，500*4K=2M

第三层树：500 * 500节点 500*500*500=1.2亿KEY，500*500*4K=1G

如果没算错，1G空间，只用三层树结构，可以存1.2亿行数据的KEY，B+树牛皮！

所以B+TREE索引只用占用很少的内存空间，却大大提升了查询效率（不论是单个查询、范围查询还是有序性查询），并且还减少了磁盘读写，所以好的算法与数据结构是可以省钱的。



**索引的创建与使用**

一张表字段有多有少，该在哪些列上创建索引呢？其实新建索引也是有一定的原则的,建什么索引,建在哪些字段上,有以下一些原则与技巧可参考：

\- 在维度高或选择性差的列创建索引 说人话就是数据列中不重复值出现的个数,这个数量越高,维度就越高（如数据表中存在8行数据a,b ,c,d,a,b,c,d这个表的维度为4）。要为维度高的列创建索引,如性别和年龄,那年龄的维度就高于性别，性别这样的列不适合创建索引,因为维度过低，只有两三种值。

\- 对 where,on,group by,order by 中出现的列使用索引，索引一般多设置在条件列上，显示列通常少设置索引

\- 对较小的数据列使用索引 ,这样会使索引文件更小,同时内存中也可以装载更多的索引键，例如有一个字段存文本内容，新闻、资讯类那种的，内容超大，你为它设置索引就是脑袋被门夹了。

\- 为较长的字符串使用前缀索引，比如有个姓名字段firstname，varchar(50)个长，可以用

alter table employee add key(firstname(5))

来设置前缀索引，为什么这里只取前5个字符进行索引呢？是因为可以通过

select 1.0 *count(distinct left(firstname,5)) / count(*) from employee

算法得到前几个字母对标数据的覆盖率，覆盖率超过31%黄金值就可以使用前缀索引。

\- 使用组合索引,可以减少文件索引大小,在使用时速度要优于多个单列索引

\- 索引也不是越多越好，不要过多创建索引,除了增加额外的磁盘空间外,对于DML操作的速度影响很大,因为其每增删改一次就得从新建立索引

说了创建索引，接下来就是使用索引，如果认真研读过前面的“执行计划”，SQL用到哪些索引，用了索引没有一目了然，但是有一些情况就是不会走索引，先来一些简单的示例说明：

SELECT sname FROM stu WHERE age+10=30; --不会使用索引,因为有索引列参与了计算

SELECT sname FROM stu WHERE LEFT(`date`,4) <1990; -- 不会使用索引,因为使用了函数运算,原理与上面相同

SELECT * FROM table WHERE uname LIKE'前缀%' -- 走索引

SELECT * FROM table WHERE uname LIKE "%关键字%"-- 不走索引

SELECT * FROM table WHERE a=1 -- a列为char字符类型，用整数找不走索引，a='1'才走索引

SELECT * FROM table WHEREdname='xxx' or loc='xx' or deptno=45

-- 如果条件中有or,即使其中有条件带索引也不会使用。换言之,就是要求使用的所有字段,都必须建立索引,建议大家尽量避免使用or关键字

-- 正则表达式,regexp不走索引

-- 表中数据不多，只有几十几百条，MySQL评估使用全表扫描要比使用索引快,也不使用索引，不要大惊小怪





## 什么是延迟加载

举个例子：如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载。 所以延迟加载即先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。
　　我们来对比一下：

关联查询：SELECT orders.*, user.username FROM orders, USER WHERE orders.user_id = user.id
延迟加载相当于：
SELECT orders.*,
(SELECT username FROM USER WHERE orders.user_id = user.id)username FROM orders

　　所以这就比较直观了，也就是说，我把关联查询分两次来做，而不是一次性查出所有的。第一步只查询单表orders，必然会查出orders中的一个user_id字段，然后我再根据这个user_id查user表，也是单表查询。

可规避部分笛卡尔积现象。

#### mybatis 延迟加载

##### 什么是延迟加载

延迟加载又叫懒加载，也叫按需加载，也就是说先加载主信息，需要的时候，再去加载从信息。代码中有查询语句，当执行到查询语句时，并不是马上去DB中查询，而是根据设置的延迟策略将查询向后推迟。

##### 什么时候会执行延迟加载

配置之后在对关联对象进行查询时使用延迟加载。

许多对延迟加载原理不太熟悉的朋友会经常遇到一些莫名其妙的问题：有些时候延迟加载 可以得到数据，有些时候延迟加载就会报错，为什么会出现这种情况呢？ MyBatis 延迟加载是通过动态代理实现的，当调用配直为延迟加载的属性方法时， 动态代 理的操作会被触发，这些额外的操作就是通过 MyBatis 的 SqlSessio口去执行嵌套 SQL 的 。 由于在和某些框架集成时， SqlSession 的生命周期交给了框架来管理，因此当对象超出 SqlSession 生命周期调用时，会由于链接关闭等问题而抛出异常 。 在和 Spring 集成时，要 确保只能在 Service 层调用延迟加载的属性 。 当结果从 Service 层返回至 Controller 层时， 如果 获取延迟加载的属性值，会因为 SqlSessio口已经关闭而抛出异常 。



**主从延迟解决方案**

由于`slave`是单线程(`I/O thread`)读取数据，单线程(`SQL thread`)更新数据，而`master`是多线程写入，那么只要`master`写入的频率大于`slave`读取更新的频率，就有可能出现主从延迟的情况，如:

1. `master`写入`tps`较高，大于`slave`更新速度；
2. `slave`执行某些语句耗时较长，如持有锁等；
3. `master`执行某些`DDL`语句时，执行的时间较长，在`slave`也执行相同的时间；

此处创建了索引，咨询 DBA，产生的`bin log`文件有100多G，数据量太大，导致从库`I/O thread`一直读取`DDL`操作产生的`bin log`事件，而影响到正常的业务`DML`事件的更新，从而表现为主从同步延迟。

从主从延迟的原因来看，解决方案可以从以下几个方向入手：

1. 业务选型，对于无法忍受从库延迟的架构，可选择分布式架构等，避开从库延迟问题
2. 执行时间，对大表进行线上`DDL`操作尽量选择凌晨等业务量较小的时候
3. 硬件配置，升级从库硬件配置，如SSD
4. 减少请求，增加缓存层，减少读请求落库